// Copyright (c) 2007 rubyamf.org (aaron@rubyamf.org)// License - http://www.gnu.org/copyleft/gpl.htmlpackage org.rubyamf.remoting.ssr{		import flash.events.*;	import flash.net.ObjectEncoding;	import flash.utils.Proxy;	import flash.utils.flash_proxy;	import org.rubyamf.remoting.ssr.RemotingConnection;		public dynamic class RemotingService extends Proxy implements IEventDispatcher	{		public static var BUSY_TIMEOUT:Number = 3500;	//server busy time		private static var PendingCalls:Number = 0;		//amount of current remoting calls		private var gateway:String;										//the gateway location		private var service:String;										//the service to call		private var connection:RemotingConnection;		//the remoting connection		private var eventDispatcher:EventDispatcher;	//concrete event dispatcher				/*		 * Constructor		 * @param gateway:String		 * @param service:String		 * @param objectEncoding:Number		 */		public function RemotingService(gate:String, serv:String, objectEncoding:Number = 3)		{			if(gate == '')				throw(new Error("Gateway cannot be null"));							if(serv == '')				throw(new Error("Service path cannot be null"));							if(objectEncoding != 0 && objectEncoding != 3)				throw(new Error("Object encoding must be 0 0r 3"));							trace("new RemotingService('" + gate + "','" + serv + "', " + objectEncoding + ")");			gateway = gate;			service = serv;			eventDispatcher = new EventDispatcher();			connection = new RemotingConnection();			connection.objectEncoding = objectEncoding;			connection.addEventListener(NetStatusEvent.NET_STATUS, onConnectionStatus);			connection.addEventListener(IOErrorEvent.IO_ERROR, onConnectionError);			connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR , onConnectionError);			connection.connect(gateway);		}				/*		 * onConnectionError		 */		private function onConnectionError(event:ErrorEvent):void		{			trace("onConnectionError: " + event.text);			dispatchEvent(new FaultEvent(FaultEvent.CONNECTION_ERROR, true, true, {text:"Connection Error: " + event.text}));		}				/*		 * onConnectionStatus		 */		private function onConnectionStatus(event:NetStatusEvent):void		{			trace("onConnectionStatus: " + event.info.code);			switch(event.info.code)			{				case "NetConnection.Call.Failed":					dispatchEvent(new FaultEvent(FaultEvent.CONNECTION_ERROR, true, true, {text:"Connection Error: " + event.info.code}));					break;			}		}				/*		 * call		 */		private function call(methodName:String, arguments:Array, onResult:Function, onFault:Function, meta:Object):void		{									var operationPath:String = service + "." + methodName.toString();			var operation:RemotingCall = new RemotingCall(connection, operationPath, onResult, onFault, arguments, meta);			operation.addEventListener(FaultEvent.AUTHENTICATION_FAILED, handleAuthFailure);			operation.execute();		}				/*		 * Authentication Failure		 */		private function handleAuthFailure(e:*):void		{			dispatchEvent(new FaultEvent(FaultEvent.AUTHENTICATION_FAILED, true,true, {text:'Authentication Failed'}));		}				/*		 * callProperty - proxy override (__resolve)		 */		flash_proxy override function callProperty(methodName:*, ...args):*		{						if(!args[3])				args[3] = {}						//if method was apply, use other args for call, this is so that you can			//make remoting calles with string methods names, not having to use eval or			//some other hack			//	 myService.apply('myMethod',args,result,fault,metaObject);  would be the same as:			//   myService.myMethod(args,result,fault,metaObject);			if(methodName == 'apply')			{				if(!args[4])					args[4] = {}								try{					call(args[0], args[1], args[2], args[3], args[4]);				}catch(error:Error) { trace(error.toString()); }			}			else			{				try {					call(methodName.toString(), args[0], args[1], args[2], args[3]);				}catch(error:Error) { trace(error.toString()); }			}			return null;		}				/*		 * hasProperty - override getters to return false always		 */  		flash_proxy override function hasProperty(name:*):Boolean		{			return false;		}				/*		 * getProperty - override getters to return null always		 */		flash_proxy override function getProperty(name:*):* 		{			return null;		}				/*		 * addHeader - public facing method to add header persistent hader to RemotingConnection		 */		public function addHeader(name:String, mustUnderstand:Boolean, value:Object):void		{			connection.AddHeader(name, mustUnderstand, value);		}				/*		 * AppendToGatewayUrl - AMF0 compliancy		 */		public function AppendToGatewayUrl(s:String):void		{			gateway += s;		}				/*		 * ReplaceGatewayUrl - replace the current gateway with new		 */		public function ReplaceGatewayUrl(newGateway:String):void		{			gateway = newGateway;		}				/*		 * setCredentials - AMF0 compliancy. Implements authencication		 */		public function setCredentials(username:String, password:String):void		{			connection.AddHeader('Credentials', false, {userid:username, password:password});		}						/*		 * addPendingCall - add a pending call. Used internally to the remoting package.		 */		public static function addPendingCall():void		{			RemotingService.PendingCalls++;		}				/*		 * removePendingCall - remove a pending call. Used internally to the remoting package.		 */		public static function removePendingCall():void		{			RemotingService.PendingCalls--;		}				/*		 * addEventListener - implement EventDispatcher		 */		public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, weakRef:Boolean = false):void 		{			eventDispatcher.addEventListener(type, listener, useCapture, priority, weakRef);		}				/*		 * dispatchEvent - implement EventDispatcher		 */		public function dispatchEvent(event:Event):Boolean 		{			return eventDispatcher.dispatchEvent(event);		}				/*		 * hasEventListener - implement EventDispatcher		 */		public function hasEventListener(type:String):Boolean 		{			return eventDispatcher.hasEventListener(type);		}				/*		 * removeEventListener - implement EventDispatcher		 */		public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void 		{			eventDispatcher.removeEventListener(type, listener, useCapture);		}				/*		 * willTrigger - implement EventDispatcher		 */		public function willTrigger(type:String):Boolean 		{			return eventDispatcher.willTrigger(type);		}	}}